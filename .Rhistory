remotes::install_github("tradingeconomics/tradingeconomics")
remotes::install_github("tradingeconomics/tradingeconomics/R/tradingeconomics")
install.packages("remotes")
library(remotes)
remotes::install_github("tradingeconomics/tradingeconomics/R/tradingeconomics", upgrade = TRUE)
setwd("~/Ottoquant_inc")
setwd(~)
setwd("~")
getwd()
devtools::install("./tradingeconomics")
devtools::install("./tradingeconomics/R/tradingeconomics")
devtools::load_all("./seasonality")
devtools::load_all("./seasonality")
setwd(~/OttoQuant_Inc)
setwd("~/OttoQuant_Inc")
source("./R_backend/R/api_utils.R")
source("./R_backend/R/tradingeconomics_utils.R")
source("./R_backend/R/general_utils.R")
library(readr)
setwd("~/seasonality")
load("./data/holiday2.Rdata")
load("./data/icnsa.Rdata")
load("./data/icsa.Rdata")
load("./data/IP.Rdata")
save(black_friday, cny, diwali, easter, file = "./data/holiday2.Rdata", version = 2)
save(initial_claims, file = "./data/icnsa.Rdata", version = 2)
save(initial_claims_SA, file = "./data/icsa.Rdata", version = 2)
save(IP, file = "./data/IP.Rdata", version = 2)
library(tradingeconomics)
login("9B8C8A6F5F1A4E1:B63971F54D7042A")
library(data.table)
library(seasonal)
devtools::load_all("~/seasonality")
source("~/OttoQuant_Inc/R_backend/R/api_utils.R")
source("~/OttoQuant_Inc/R_backend/R/tradingeconomics_utils.R")
source("~/OttoQuant_Inc/R_backend/R/general_utils.R")
DT <- fread("C:/Users/seton/Dropbox/OttoQuant/data/usa_data_sa.csv")
lib <- fread("C:/Users/seton/Dropbox/OttoQuant/data/usa_library.csv")
library(tradingeconomics)
login("9B8C8A6F5F1A4E1:B63971F54D7042A")
library(data.table)
library(seasonal)
devtools::load_all("~/seasonality")
source("~/OttoQuant_Inc/R_backend/R/api_utils.R")
source("~/OttoQuant_Inc/R_backend/R/tradingeconomics_utils.R")
source("~/OttoQuant_Inc/R_backend/R/general_utils.R")
DT <- fread("C:/Users/seton/Dropbox/OttoQuant/data/usa_data_sa.csv")
lib <- fread("C:/Users/seton/Dropbox/OttoQuant/data/usa_library.csv")
sys_date_if_na <- function(pub_date){
if(is.na(pub_date)){
return(Sys.Date())
}else{
return(pub_date)
}
}
min_or_NA <- function(pub_date){
if(all(is.na(pub_date))){
return(NA)
}else{
return(min(pub_date, na.rm = TRUE))
}
}
DT[, ref_date := as.Date(ref_date)]
DT[, pub_date := as.Date(pub_date)]
te_series <- lib[source == "TradingEconomics"]$series_name
#Data for which there are forecasts & pub dates
new_data <- getCalendarData(country = "United States", initDate = Sys.Date()-3, endDate = Sys.Date())
new_data <- rbindlist(new_data)
new_data <- new_data[ ,.(Date, Country, Category, Reference, Actual, Forecast)]
new_data[ , series_name := tolower(Category)]
new_data[ , Category := NULL]
new_data <- new_data[ series_name%in%tolower(te_series)]
calendar_names <- new_data$series_name
if(NROW(new_data)>0){
new_data[ , pub_date := as.Date(as.character(lapply(Date, FUN = substr, start = 1, stop = 10)))]
new_data[ , Date := NULL]
new_data[ , ref_date := do.call("c",mapply(FUN = Reference_to_date, Reference, pub_date, SIMPLIFY = FALSE)) ]
new_data[ , Reference := NULL]
new_data[ , country := tolower(Country)]
new_data[ , Country := NULL]
new_data[ , value := extract_numeric(Actual)]
new_data[ , Actual := NULL]
new_data[ , forecast := extract_numeric(Forecast)]
new_data[ , Forecast := NULL]
setcolorder(new_data, c("country", "series_name", "ref_date", "value", "pub_date", "forecast"))
DTT <- rbind(DT, new_data)
}
#everything else
te_remaining <- te_series[!te_series%in%calendar_names]
new_data <- lapply(te_remaining, FUN = TE_indicator_data, country = "United States") #slow!!
new_data <- rbindlist(lapply(new_data, rbindlist))
new_data <- new_data[ ,.(LatestValueDate, Country, Category, LatestValue)]
new_data[ , ref_date := as.Date(as.character(lapply(LatestValueDate, FUN = substr, start = 1, stop = 10)))]
new_data[ , LatestValueDate := NULL]
new_data[ , country := tolower(Country)]
new_data[ , Country := NULL]
new_data[ , series_name := tolower(Category)]
new_data[ , Category := NULL]
colnames(new_data)[colnames(new_data) == "LatestValue"] <- "value"
new_data[ , pub_date := Sys.Date()]
new_data[ , forecast := NA]
setcolorder(new_data, c("country", "series_name", "ref_date", "value", "pub_date", "forecast"))
DTT <- rbind(DTT, new_data)
usa_exp <- Get_FRED_Data(series_id = "AITGEXS", series_name = "goods exports", observation_start = Sys.Date()-60)
usa_ex <- tail(usa_exp,1)
usa_imp <- Get_FRED_Data(series_id = "AITGIXS", series_name = "goods imports", observation_start = Sys.Date()-60)
usa_imp <- tail(usa_imp,1)
usa_goods <- data.table(rbind(usa_ex, usa_imp))
usa_goods[ , value := value/1000]
usa_goods[ , pub_date := Sys.Date()]
usa_goods[ , forecast := NA]
usa_goods[ , country := "united states"]
usa_goods[ , ref_date := end_of_month(date)]
usa_goods[ , date := NULL]
setcolorder(usa_goods, c("country", "series_name", "ref_date", "value", "pub_date", "forecast"))
DTT <- rbind(DTT, usa_goods)
DTT <- DTT[order(country, series_name, ref_date)]
DTT[ , pub_date := as.Date(min_or_NA(pub_date)), by = c("country", "series_name", "ref_date")]
DTT <- unique(DTT,  fromLast = TRUE, by = c("country", "series_name", "ref_date"))
DT_SA <- seasonally_adjust_TE(DT = DTT, lib = lib, country_id = "united states")
tmp <- DTT[series_name%in%unique(DT_SA$series_name)]
colnames(tmp)[colnames(tmp) == "value"] <- "old_value"
DT_SA <- merge(tmp, DT_SA, by = c("country", "series_name", "ref_date"), all = TRUE)
DT_SA[is.na(value), value := old_value]
DT_SA[ , max_ref_date := max(ref_date) , by = c("country", "series_name") ]
DT_SA[ref_date == max_ref_date, pub_date := do.call("c", lapply(pub_date, FUN = sys_date_if_na))]
DT_SA[ , old_value := NULL]
DT_SA[ , max_ref_date := NULL]
setcolorder(DT_SA, c("country", "series_name", "ref_date", "value", "pub_date", "forecast"))
DTT <- DTT[!series_name%in%unique(DT_SA$series_name)]
DTT <- rbind(DTT, DT_SA)
devtools::load_all("./seasonality")
devtools::load_all("~/seasonality")
DT_SA
DT_SA <- seasonally_adjust_TE(DT = DTT, lib = lib, country_id = "united states")
tmp <- DTT[series_name%in%unique(DT_SA$series_name)]
colnames(tmp)[colnames(tmp) == "value"] <- "old_value"
DT_SA <- merge(tmp, DT_SA, by = c("country", "series_name", "ref_date"), all = TRUE)
DT_SA[is.na(value), value := old_value]
DT_SA[ , max_ref_date := max(ref_date) , by = c("country", "series_name") ]
DT_SA[ref_date == max_ref_date, pub_date := do.call("c", lapply(pub_date, FUN = sys_date_if_na))]
DT_SA[ , old_value := NULL]
DT_SA[ , max_ref_date := NULL]
setcolorder(DT_SA, c("country", "series_name", "ref_date", "value", "pub_date", "forecast"))
DTT <- DTT[!series_name%in%unique(DT_SA$series_name)]
DTT <- rbind(DTT, DT_SA)
DTT
View(DTT)
write.csv(DTT, file = "C:/Users/seton/Dropbox/OttoQuant/data/usa_data_sa_test.csv", row.names = FALSE)
DTT
tester <- data.table(country = "Narnia", series_name = "Lions", "ref_date" = as.Date("1843-02-01"), value = 1,
pub_date = as.Date("2019-01-01"), forecast = 2)
tester
DTT <- rbind(DTT, tester)
DTT
library(seasonality)
library(seasonality)
library(seasonality)
library(seasonality)
#setwd("~/OttoQuant_Inc")
#setwd("/root") # docker run
library(devtools, quietly = TRUE)
library(data.table, quietly = TRUE)
library(Rcpp, quietly = TRUE)
library(parallel)
library(Matrix)
library(seasonal)
library(seasonality)
library(VARMA)
library(Rbackend)
method <- "DFMI" #"DFMI", "VAR", "OQ"
lags <- 3
factors <- 2
target <- 1
smooth <- 1
filter <- 1
do_not_filter <- NULL
needs_SA_target <- c(FALSE, FALSE)
needs_SA_covars <- rep(FALSE, 12)
needs_SA_covars[12] <- TRUE #just for testing
set_frequency <- NULL
target_data <- fread("~/OttoQuant_Inc/preliminary/data/target_long.csv")
covar_data <- fread("~/OttoQuant_Inc/preliminary/data/covar_long.csv")
input_to_wide <- function(input_data){
#our internal format
if(all(c("country", "series_name", "ref_date", "value")%in%colnames(input_data))){
out <- dcast(input_data, ref_date ~ country + series_name, value.var = "value", fun.aggregate = mean_NA)
}else{
Cnames <- colnames(input_data)
#Cnames[1] <- "ref_date" #this is done in python code
colnames(input_data)[length(Cnames)] <- "value"
out <- data.table::dcast(input_data, ref_date ~ ..., value.var = "value", fun.aggregate = mean_NA)
}
return(out)
}
suppressMessages(
library(devtools),
library(data.table),
library(Rcpp),
library(parallel),
library(Matrix),
library(seasonal),
library(seasonality),
library(VARMA),
library(Rbackend)
)
library(devtools)
suppressMessages(library(data.table))
library(Rcpp)
library(parallel)
library(Matrix)
library(seasonal)
library(seasonality)
library(VARMA)
library(Rbackend)
method <- "DFMF" #"DFMI", "VAR", "OQ"
lags <- 3
factors <- 2
target <- 1
smooth <- 1
filter <- 1
do_not_filter <- NULL
needs_SA_target <- c(FALSE, FALSE)
needs_SA_covars <- rep(FALSE, 12)
needs_SA_covars[12] <- TRUE #just for testing
set_frequency <- NULL
target_data <- fread("~/OttoQuant_Inc/preliminary/data/target_long.csv")
covar_data <- fread("~/OttoQuant_Inc/preliminary/data/covar_long.csv")
input_to_wide <- function(input_data){
#our internal format
if(all(c("country", "series_name", "ref_date", "value")%in%colnames(input_data))){
out <- dcast(input_data, ref_date ~ country + series_name, value.var = "value", fun.aggregate = mean_NA)
}else{
Cnames <- colnames(input_data)
#Cnames[1] <- "ref_date" #this is done in python code
colnames(input_data)[length(Cnames)] <- "value"
out <- data.table::dcast(input_data, ref_date ~ ..., value.var = "value", fun.aggregate = mean_NA)
}
return(out)
}
if(!is.null(set_frequency)){
set_frequency <- tolower(set_frequency)
if(set_frequency%in%c("quarterly", "q")){
set_frequency <- 92
}else if(set_frequency%in%c("monthly", "m")){
set_frequency <- 31
}else if(set_frequency%in%c("weekly", "w")){
set_frequency <- 7
}else if(set_frequency%in%c("daily","d")){
set_frequency <- 1
}
}
if(!is.null(target_data)){
#data is entered in long format and needs to be converted to wide for estimation
target_data <- data.table(target_data)
covar_data <- data.table(covar_data)
target_data[ , ref_date := as.Date(ref_date)] #name ref_date assigned in python
covar_data[ , ref_date := as.Date(ref_date)] #name ref_date assigned in python
y <- input_to_wide(target_data)
k_target <- ncol(y)-1
# Target data processing
tgt_frq <- max(get_freq_dt(y))
if(!is.null(set_frequency)){
if(set_frequency < min(get_freq_dt(y))){
stop("User defined frequency must be greater than or equal to the highest frequency in the target data")
}else{
tgt_frq <- set_frequency
}
}
if(tgt_frq > 89 && tgt_frq < 94){
dt <- agg_to_quarterly(y, date_name = "ref_date")
w  <- dt$W
y  <- dt$dt
}else if(tgt_frq >27 && tgt_frq < 32){
dt <- agg_to_monthly(y, date_name = "ref_date")
w  <- dt$W
y  <- dt$dt
}else if(tgt_frq > 4 && tgt_frq < 8){
dt <- agg_to_weekly(y, date_name = "ref_date")
w  <- dt$W
y  <- dt$dt
}else{
w <- data.table(ref_date = y$ref_date, matrix(1,NROW(y),NCOL(y)-1))
}
y <- add_forecast_dates(y, forecast = 12)
processed <- process_targets(y, needs_SA = needs_SA_target)
if(is.null(covar_data)){
Y <- processed$data
W <- w
}
}
dt <- agg_to_monthly(y, date_name = "ref_date")
library(seasonality)
library(seasonality)
library(seasonality)
#
# library(data.table)
# load("~/seasonality/data/icnsa.RData")
# load("~/seasonality/data/holiday2.RData")
# library(devtools)
# load_all("~/seasonality")
# initial_claims_SA <- initial_claims_SA[-nrow(initial_claims_SA),]
# save(initial_claims_SA, file = "~/seasonality/data/icsa.RData")
#this can also be entered as a ts_boxable object
dates <- as.Date(initial_claims$DATE)
data  <- initial_claims$ICNSA
start_time <- Sys.time()
SA <- auto_SA(data = data, dates = dates)
end_time <- Sys.time()
end_time - start_time
library(seasonality)
library(seasonality)
library(seasonality)
#
# library(data.table)
# load("~/seasonality/data/icnsa.RData")
# load("~/seasonality/data/holiday2.RData")
# library(devtools)
# load_all("~/seasonality")
# initial_claims_SA <- initial_claims_SA[-nrow(initial_claims_SA),]
# save(initial_claims_SA, file = "~/seasonality/data/icsa.RData")
#this can also be entered as a ts_boxable object
dates <- as.Date(initial_claims$DATE)
data  <- initial_claims$ICNSA
start_time <- Sys.time()
SA <- auto_SA(data = data, dates = dates)
end_time <- Sys.time()
end_time - start_time
plot(dates, data, type = "l", lwd = 3, col = "lightskyblue1",
xlab = "Dates", ylab = "Initial Claims")
lines(dates, SA$data_sa, col = "black")
#ts.plot(cbind(data_weekly, SA$data_sa), col = c("red", "blue")) #could use some fine tuining but pretty good!
plot(dates, SA$data_sa, type = "l", lwd = 3, col = "lightskyblue1",
xlab = "Dates", ylab = "Initial Claims")
lines(dates, initial_claims_SA$ICSA, col = "black")
SA$ar_effect
SA$ma_effect
SA$parameters
data <- IP$IPNSA
dates <- IP$DATE
SA <- auto_SA(data = data, dates = dates)
y <- ts(data, start = c(1970,1), frequency = 12)
library(seasonal)
sa <- seas(y)
plot(dates[-1], diff(log(SA$data_sa)), type = "l", lwd = 1, col = "blue",
xlab = "Dates", ylab = "IP")
lines(dates[-1], diff(log(final(sa))), lwd = 1, col = "red")
SA$ar_effect
SA$ma_effect
summary(sa)
#test agains auto.arima
library(forecast)
data <- IP$IPNSA
dates <- IP$DATE
trend <- loess(data ~ seq(length(data)), span = .1, na.action = na.exclude) #refine parameter selection
trend <- predict(trend)
#ts.plot(cbind(trend, data), col = c("red", "blue"))
y <- data - trend
SA <- auto_SA(y, dates, detrend = FALSE)
y <- ts(data, start = c(1970,1), frequency = 12)
aa <- auto.arima(y)
summary(aa) #0.423
SA$MSE #0.302
SA <- auto_SA(y, dates)
ts.plot(cbind(y, SA$data_sa), col = c("blue", "red"))
#
SA <- auto_SA(y, dates, detrend = FALSE)
SA <- auto_SA(data = data, dates = dates)
data <- IP$IPNSA
dates <- IP$DATE
SA <- auto_SA(data = data, dates = dates)
data <- IP$IPNSA
dates <- IP$DATE
SA <- auto_SA(data = data, dates = dates)
library(seasonality)
data <- IP$IPNSA
dates <- IP$DATE
SA <- auto_SA(data = data, dates = dates)
library(seasonality)
#
# library(data.table)
# load("~/seasonality/data/icnsa.RData")
# load("~/seasonality/data/holiday2.RData")
# library(devtools)
# load_all("~/seasonality")
# initial_claims_SA <- initial_claims_SA[-nrow(initial_claims_SA),]
# save(initial_claims_SA, file = "~/seasonality/data/icsa.RData")
#this can also be entered as a ts_boxable object
dates <- as.Date(initial_claims$DATE)
data  <- initial_claims$ICNSA
start_time <- Sys.time()
SA <- auto_SA(data = data, dates = dates)
end_time <- Sys.time()
end_time - start_time
#ts.plot(cbind(data_weekly, SA$data_sa), col = c("red", "blue")) #could use some fine tuining but pretty good!
plot(dates, data, type = "l", lwd = 3, col = "lightskyblue1",
xlab = "Dates", ylab = "Initial Claims")
lines(dates, SA$data_sa, col = "black")
#ts.plot(cbind(data_weekly, SA$data_sa), col = c("red", "blue")) #could use some fine tuining but pretty good!
plot(dates, SA$data_sa, type = "l", lwd = 3, col = "lightskyblue1",
xlab = "Dates", ylab = "Initial Claims")
lines(dates, initial_claims_SA$ICSA, col = "black")
library(seasonality)
#Basic examples
library(seasonality)
#
# library(data.table)
# load("~/seasonality/data/icnsa.RData")
# load("~/seasonality/data/holiday2.RData")
# library(devtools)
# load_all("~/seasonality")
# initial_claims_SA <- initial_claims_SA[-nrow(initial_claims_SA),]
# save(initial_claims_SA, file = "~/seasonality/data/icsa.RData")
#this can also be entered as a ts_boxable object
dates <- as.Date(initial_claims$DATE)
data  <- initial_claims$ICNSA
start_time <- Sys.time()
SA <- auto_SA(data = data, dates = dates)
end_time <- Sys.time()
end_time - start_time
#ts.plot(cbind(data_weekly, SA$data_sa), col = c("red", "blue")) #could use some fine tuining but pretty good!
plot(dates, data, type = "l", lwd = 3, col = "lightskyblue1",
xlab = "Dates", ylab = "Initial Claims")
lines(dates, SA$data_sa, col = "black")
#ts.plot(cbind(data_weekly, SA$data_sa), col = c("red", "blue")) #could use some fine tuining but pretty good!
plot(dates, SA$data_sa, type = "l", lwd = 3, col = "lightskyblue1",
xlab = "Dates", ylab = "Initial Claims")
lines(dates, initial_claims_SA$ICSA, col = "black")
data <- IP$IPNSA
dates <- IP$DATE
SA <- auto_SA(data = data, dates = dates)
y <- ts(data, start = c(1970,1), frequency = 12)
library(seasonal)
sa <- seas(y)
plot(dates[-1], diff(log(SA$data_sa)), type = "l", lwd = 1, col = "blue",
xlab = "Dates", ylab = "IP")
lines(dates[-1], diff(log(final(sa))), lwd = 1, col = "red")
library(forecast)
data <- IP$IPNSA
dates <- IP$DATE
trend <- loess(data ~ seq(length(data)), span = .1, na.action = na.exclude) #refine parameter selection
trend <- predict(trend)
#ts.plot(cbind(trend, data), col = c("red", "blue"))
y <- data - trend
SA <- auto_SA(y, dates, detrend = FALSE)
y <- ts(data, start = c(1970,1), frequency = 12)
aa <- auto.arima(y)
summary(aa) #0.423
SA$MSE #0.302
SA <- auto_SA(y, dates)
ts.plot(cbind(y, SA$data_sa), col = c("blue", "red"))
library(seasonality)
library(seasonality)
install.packages(c('Rcpp', 'RcppArmadillo','seasonal','devtools',
'R.utils', 'jsonlite',
'data.table', 'readr', 'Matrix'),
repo = 'https://cloud.r-project.org')
library(seasonality)
